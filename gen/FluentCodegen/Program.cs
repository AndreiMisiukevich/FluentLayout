using System;
using System.IO;
using Xamarin.Forms;
using System.Linq;
using System.Reflection;
using System.Text;

namespace FluentCodegen
{
    class MainClass
    {
        private const string ClassTemplate =
@"// This file is generated by FluentCodegen
// It does not make sense to change something here
// No stress :)
using System;
namespace Xamarin.Forms.Fluent
{{
    public static partial class {0}Extensions
    {{
{1}
    }}
}}";

        private const string MethodTemplate =
@"
        {3}
        public static TBindable Bind{0}{1}<TBindable>(this TBindable self,
            string path,
            BindingMode mode = BindingMode.Default,
            IValueConverter converter = null,
            object converterParameter = null,
            string stringFormat = null,
            object source = null,
            object targetNullValue = null,
            object fallbackValue = null) where TBindable : {1}
                => self.Bind({1}.{2}, path, mode, converter, converterParameter, stringFormat, source, targetNullValue, fallbackValue);";

        private const string SealedClassMethodTemplate =
    @"
        {3}
        public static {1} Bind{0}{1}(this {1} self,
            string path,
            BindingMode mode = BindingMode.Default,
            IValueConverter converter = null,
            object converterParameter = null,
            string stringFormat = null,
            object source = null,
            object targetNullValue = null,
            object fallbackValue = null)
                => self.Bind({1}.{2}, path, mode, converter, converterParameter, stringFormat, source, targetNullValue, fallbackValue);";

        private const string SetValueMethodTemplate =
    @"
        {4}
        public static TBindable {0}<TBindable>(this TBindable bindable, {3} value) where TBindable : BindableObject
            => bindable.Set({2}.{1}, value);";

        public static void Main(string[] args)
        {
            var bindableObjType = typeof(BindableObject);
            var bindablePropType = typeof(BindableProperty);
            var obsoleteType = typeof(ObsoleteAttribute);

            var codegenPath = Path.GetFullPath(Path.Combine(Environment.CurrentDirectory, @"../../../../lib/FluentLayout/Codegen/"));

            var dir = new DirectoryInfo(codegenPath);
            foreach(var file in dir.GetFiles())
            {
                file.Delete();
            }

            var formsAssembly = typeof(Application).Assembly;
            var formsTypes = formsAssembly
                .GetTypes()
                .Where(t => t.IsSubclassOf(bindableObjType) || t == bindableObjType)
                .Where(t => !t.IsGenericType);
            

            foreach(var type in formsTypes)
            {
                var props = type.GetFields(BindingFlags.Static | BindingFlags.Public).Where(p => p.FieldType == bindablePropType);
                if (!props.Any())
                {
                    continue;
                }
                var typeName = type.Name;
                var methodsBuilder = new StringBuilder();
                foreach(var prop in props)
                {
                    var propertyName = prop.Name.Replace("Property", string.Empty);
                    try
                    {
                        var bindablePropInstance = prop.GetValue(null);
                        var propertyNameInfo = bindablePropInstance.GetType().GetProperty("PropertyName", BindingFlags.Instance | BindingFlags.Public);
                        propertyName = propertyNameInfo.GetValue(bindablePropInstance).ToString();
                    }
                    catch
                    {
                        //ignore
                    }
                    var methodInfo = type.GetMethod($"Set{propertyName}", BindingFlags.Static | BindingFlags.Public); //attached
                    var constraintTypeName = methodInfo == null ? typeName : bindableObjType.Name;

                    var isObsolete = prop.CustomAttributes.Any(x => x.AttributeType == obsoleteType);

                    methodsBuilder.Append(string.Format(type.IsSealed ? SealedClassMethodTemplate : MethodTemplate, 
                        isObsolete ? prop.Name.Replace("Property", string.Empty) : propertyName, 
                        typeName, 
                        prop.Name, 
                        isObsolete ? "\n[Obsolete]" : string.Empty));

                    if(methodInfo != null)
                    {
                        var paramTypeName = methodInfo.GetParameters().Last().ParameterType.Name;
                        methodsBuilder.Append(string.Format(SetValueMethodTemplate, methodInfo.Name, prop.Name, type.Name, paramTypeName, methodInfo.CustomAttributes.Any(x => x.AttributeType == obsoleteType) ? "\n[Obsolete]" : string.Empty));
                    }
                }

                var fullCode = string.Format(ClassTemplate, typeName, methodsBuilder);

                var filePath = Path.Combine(codegenPath, $"{typeName}Extensions.codegen.cs");
                File.WriteAllText(filePath, fullCode);
            }

            Console.WriteLine($"Ended... {formsTypes.Count()} files were generated");
            Console.ReadLine();
        }
    }
}
