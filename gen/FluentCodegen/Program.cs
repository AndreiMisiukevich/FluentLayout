using System;
using System.IO;
using Xamarin.Forms;
using System.Linq;
using System.Reflection;
using System.Text;

namespace FluentCodegen
{
    class MainClass
    {
        private const string ClassTemplate =
@"// This file is generated by FluentCodegen
// It does not make sense to change something here
// No stress :)
using System;
namespace Xamarin.Forms.Fluent
{{
    public static partial class {0}Extensions
    {{
{1}
    }}
}}";

        private const string MethodTemplate =
@"
        {3}
        public static TBindable Bind{0}{1}<TBindable>(this TBindable self,
            string path,
            BindingMode mode = BindingMode.Default,
            IValueConverter converter = null,
            object converterParameter = null,
            string stringFormat = null,
            object source = null,
            object targetNullValue = null,
            object fallbackValue = null) where TBindable : {1}
                => self.Bind({1}.{2}, path, mode, converter, converterParameter, stringFormat, source, targetNullValue, fallbackValue);";

        private const string SealedClassMethodTemplate =
    @"
        {3}
        public static {1} Bind{0}{1}(this {1} self,
            string path,
            BindingMode mode = BindingMode.Default,
            IValueConverter converter = null,
            object converterParameter = null,
            string stringFormat = null,
            object source = null,
            object targetNullValue = null,
            object fallbackValue = null)
                => self.Bind({1}.{2}, path, mode, converter, converterParameter, stringFormat, source, targetNullValue, fallbackValue);";

        private const string SetValueMethodTemplate =
    @"
        {4}
        public static TBindable {0}<TBindable>(this TBindable bindable, {3} value) where TBindable : BindableObject
            => bindable.Set({2}.{1}, value);";

        private const string WithEventMethodTemplate = @"

        public static TBindable With{1}{0}Event<TBindable>(this TBindable self,
            {2} handlerAction) where TBindable : {1}
        {{
            self.{0} += handlerAction;

            return self;
        }}";

        private const string ClearEventHandlersMethodTemplate = @"

        public static TBindable Clear{1}{0}Handlers<TBindable>(this TBindable self) where TBindable : {1}
        {{
            Xamarin.Forms.Fluent.EventExtensions.ClearEventInvocations(self, ""{0}"");

            return self;
        }}";

        public static void Main(string[] args)
        {
            var bindableObjType = typeof(BindableObject);
            var bindablePropType = typeof(BindableProperty);
            var obsoleteType = typeof(ObsoleteAttribute);

            var codegenPath = Path.GetFullPath(Path.Combine(Environment.CurrentDirectory, @"../../../../lib/FluentLayout/Codegen/"));

            var dir = new DirectoryInfo(codegenPath);
            foreach (var file in dir.GetFiles())
            {
                file.Delete();
            }

            var formsAssembly = typeof(Application).Assembly;
            var formsTypes = formsAssembly
                .GetTypes()
                .Where(t => t.IsSubclassOf(bindableObjType) || t == bindableObjType)
                .Where(t => !t.IsGenericType);


            foreach (var type in formsTypes)
            {
                var props = type.GetFields(BindingFlags.Static | BindingFlags.Public).Where(p => p.FieldType == bindablePropType);
                if (!props.Any())
                {
                    continue;
                }
                var typeName = type.Name;
                var methodsBuilder = new StringBuilder();

                TryHandleEventHandlers(methodsBuilder, type);

                foreach (var prop in props)
                {
                    var propertyName = prop.Name.Replace("Property", string.Empty);
                    try
                    {
                        var bindablePropInstance = prop.GetValue(null);
                        var propertyNameInfo = bindablePropInstance.GetType().GetProperty("PropertyName", BindingFlags.Instance | BindingFlags.Public);
                        propertyName = propertyNameInfo.GetValue(bindablePropInstance).ToString();
                    }
                    catch
                    {
                        //ignore
                    }
                    var methodInfo = type.GetMethod($"Set{propertyName}", BindingFlags.Static | BindingFlags.Public); //attached
                    var constraintTypeName = methodInfo == null ? typeName : bindableObjType.Name;

                    var isObsolete = prop.CustomAttributes.Any(x => x.AttributeType == obsoleteType);

                    methodsBuilder.Append(string.Format(type.IsSealed ? SealedClassMethodTemplate : MethodTemplate,
                        isObsolete ? prop.Name.Replace("Property", string.Empty) : propertyName,
                        typeName,
                        prop.Name,
                        isObsolete ? "\n[Obsolete]" : string.Empty));

                    if (methodInfo != null)
                    {
                        var paramTypeName = methodInfo.GetParameters().Last().ParameterType.Name;
                        methodsBuilder.Append(string.Format(SetValueMethodTemplate, methodInfo.Name, prop.Name, type.Name, paramTypeName, methodInfo.CustomAttributes.Any(x => x.AttributeType == obsoleteType) ? "\n[Obsolete]" : string.Empty));
                    }
                }

                var fullCode = string.Format(ClassTemplate, typeName, methodsBuilder);

                var filePath = Path.Combine(codegenPath, $"{typeName}Extensions.codegen.cs");
                File.WriteAllText(filePath, fullCode);
            }

            Console.WriteLine($"Ended... {formsTypes.Count()} files were generated");
            Console.ReadLine();
        }

        private static void TryHandleEventHandlers(StringBuilder methodsBuilder, Type type)
        {
            // Can't create generic methods for sealed types (i.e SwipeGestureRecognizer)
            if (!type.IsSealed &&
                // Don't try to generate event handlers for anything that is NOT a VisualElement
                type.IsSubclassOf(typeof(VisualElement)))
            {
                var events = type.GetEvents();

                if (events?.Any() == true)
                {
                    foreach (var e in events)
                    {
                        string eventHandlerType = ToReadableString(e.EventHandlerType);

                        methodsBuilder.Append(string.Format(WithEventMethodTemplate, e.Name, type.Name, eventHandlerType));
                        methodsBuilder.Append(string.Format(ClearEventHandlersMethodTemplate, e.Name, type.Name));
                    }
                }
            }
        }

        private static string ToReadableString(Type type)
        {
            return type.ToString()
                .Replace("`1[", "<")
                .Replace("]", ">")
                .Replace("+", ".");
        }
    }
}
